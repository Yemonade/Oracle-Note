# Attention

- `/`执行上一条命令

- `;`一定记得要以分号结尾

- 在一个`grant`语句中，不能将系统权限和对象权限一起授予

- 表名在引号内注意大写：`upper`

- 设置 sqlplus 的语句不用分号，如desc xxx;

  `savepoint sp0;`

  - 注意`create`中的`,`

- 注意`declare a number;` 中的`;`

- `dbms_output.put_line(i);`

- `for i in 1..10 loop`   不能写三个点

- `if ... then`

- 显式游标记得 close

- 抛出异常还没有看

- 关注一下`end xxx`?

- % ：表示任意0个或多个字符

  _ ： 表示任意单个字符。

- 更新的时候注意要不要考虑若不存在该行则创建

- number(7,2) is a number that has 5 digits before the decimal and 2 digits after the decimal.

- order 默认升序排序

- 动态sql不要`;`



整理一下数据类型通用操作

提高大表查询效率？

有无逐渐的效率？空间消耗？（实验三）





#### 2. 4 执行SQL查询语句的步骤

SQL语句的执行主要由用户进程与服务器进程来完成的，其他的一些进程可能要辅助完成这一过程。查询语句与其他的SQL语句有所不同，如果一个查询语句执行成功，就要返回查询的结果，而其他的SQL语句只是返回执行成功或失败的信息。

查询语句的处理主要包括：编译（parse）、执行（execute）和提取数据（fetch）。
1.编译：在进行编译时，服务器进程会将SQL语句的正文放入共享池（shared pool）的库高速缓存（library cache）中并将完成以下处理：

- 首先在共享池中搜索是否有相同的SQL语句，如果没有就进行后续的处理；

- 检查该SQL语句的语法是否正确

- 通过查看数据字典来检查表和列的定义；

- 对所操作的对象加编译锁（parse locks），以便在编译语句期间这些对象的定义不能被改变；

- 检查所引用对象的用户权限；

- 生成执行该SQL语句的所需的优化的执行计划（执行步骤）；

- 将SQL语句和执行计划装入共享的SQL区。

  

以上的每一步操作都是在处理正确时才进行后续的处理，如果不正确，就返回错误。

2. 执行（execute）：Oracle服务器进程开始执行SQL语句是因为它已获得了执行SQL语句所需的全部资源和信息。
   3.提取数据（fetch）：Oracle服务器进程选择所需的数据行，并在需要时将其排序，最后将结果返回给用户进程。





# 数据库用户管理

## 用户类型

**超级用户 sys**

- sys 用户是超级用户，具有最高权限，具有 sysdba 角色，有`create database`的权限，该用户默认的密码是 sys
- 登录语句 `SQL>conn sys/sys as sysdba;`



**管理操作员 sysoper**

- system 用户是管理操作员，权限也很大。具有 sysoper 角色，没有`create database`的权限，默认的密码是manager
- 登录语句 `SQL> conn system/manager;`
- sys 和 system 这两个用户最大的区别是在于有没有`create database`的权限



**普通用户**

- scott 用户是普通用户，密码默认为 tiger ,默认未解锁
- 解锁语句 `SQL>alter user scott account unlock;`
- 登录语句 `SQL> conn scott/tiger;`





**视图**

视图其实是一个虚拟的表，它的数据其实来自于表。如果更改了视图的数据，表的数据也自然会变化，更改了表的数据，视图也自然会变化。==一个视图所存储的并不是数据，而是一条 SQL语句==
改视图基表数据也会发生变化

1. 简化数据操作：视图可以简化用户处理数据的方式。

2. 着重于特定数据：不必要的数据或敏感数据可以不出现在视图中。 

3. 视图提供了一个简单而有效的安全机制，可以定制不同用户对数据的访问权限。 

4. 提供向后兼容性：视图使用户能够在表的架构更改时为表创建向后兼容接口。

视图一定要有列名，且不能冲突



**索引**

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。



**B+树索引与位图索引**

在内部，位图和btree索引有很大的不同，但是在功能上它们是相同的，因为它们用于帮助Oracle以比全表扫描更快的速度检索行。B树索引和位图索引之间的基本区别包括：

语法差异：位图索引包含“ bitmap”关键字。btree索引不显示“位图”。
基数差异：位图索引通常适用于具有大量重复值（低基数）的列，而b树索引最适合于高基数列。
内部结构差异：内部结构差异很大。b树索引具有索引节点（基于数据块大小），它是树形式：

![](https://img-blog.csdnimg.cn/20200618202214668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcmdpZXgy,size_16,color_FFFFFF,t_70)


位图索引如下所示，这是一个具有零和一个（位）值的二维数组：

![](https://img-blog.csdnimg.cn/20200618202214763.png)





B树索引
B树索引用于避免大型排序操作。例如，要求按排序顺序显示10,000行的SQL查询通常会使用B树索引，以避免在查询时还需要占用临时空间进行数据排序。

虽然B树索引非常适合简单查询，但在以下情况下它们并不是很好：

低基数列：具有小于200个枚举值的列，在使用标准B树索引时，带来的收益不大。
不支持SQL函数：在SQL查询时，B树索引无法使用Oracle的内置函数。Oracle提供了多种内置函数，允许SQL语句查询索引列的某一部分，或查询索引列的转换结果，但建立的如果不是函数索引，则针对字段的索引在有函数（除max, min之外）引用时，索引将失效。
在引入基于Oracle函数的索引（FBI）之前，由于这些缺点，基于Oracle成本的SQL优化器必须执行耗时的全表扫描。因此，Oracle引入更强大的索引结构类型也就不足为奇了。

位图索引
Oracle位图索引与标准B树索引非常不同。在位图结构中，将创建一个二维数组，其中索引表中的每一行都有一列。每列代表位图索引中的不同值。此二维数组表示索引中的每个值乘以表中的行数。在行检索时，Oracle将位图解压缩到RAM数据缓冲区中，以便可以对其进行快速扫描以查找匹配的值。这些匹配值以行ID列表的形式传递给Oracle，并且这些行ID值可以直接访问所需的信息。

当一个表包含多个位图索引时，位图索引的真正好处就出现了。每个单独的列可能具有低基数。多个位图索引的创建提供了一种非常强大的方法，可以快速回答复杂的SQL查询。

Oracle使用一种称为位图索引合并的特殊优化器方法来为该查询提供服务。在位图索引合并中，每个Row-ID或RID列表都是通过使用位图独立构建的，并且使用特殊的合并例程来比较RID列表并找到相交的值。使用这种方法，Oracle在处理多个低基数列时可以提供亚秒级的响应时间。



**动态SQL**

Oracle编译PL/SQL程序块分为两个种：一种为前期联编（early binding），即SQL语句在程序编译期间就已经确定，大多数的编译情况属于这种类型；另外一种是后期联编（late binding），即SQL语句只有在运行阶段才能建立，例如当查询条件为用户输入时，那么Oracle的SQL引擎就无法在编译期对该程序语句进行确定，只能在用户输入一定的查询条件后才能提交给SQL引擎进行处理。


在PL/SQL开发过程中，使用SQL或PL/SQL可以实现大部分的需求，但是，在某些特殊的情况下，在PL/SQL中使用标准的SQL语句或DML语句不能实现自己的需求，例如需要动态建表或执行某个不确定的操作的时候，就需要动态执行，还有DDL语句及系统控制语句都不能在PL/SQL中直接使用，这就需要使用动态SQL来实现。

因此，在Oracle数据库开发PL/SQL块中，可以把SQL分为静态SQL和动态SQL。



所谓静态SQL指的是在PL/SQL块中使用的SQL语句在编译时是明确的，执行的是确定对象。



动态SQL是指在PL/SQL块编译时SQL语句是不确定的，如根据用户输入的参数的不同而执行不同的操作。编译程序对动态语句部分不进行处理，只是在程序运行时动态地创建语句、对语句进行语法分析并执行该语句。



动态SQL允许在SQL客户模块或嵌入式宿主程序的执行过程中执行动态生成的SQL语句，动态SQL语句在程序编译时尚未确定。其中，有些部分需要在程序的执行过程中临时生成的SQL语句，SQL标准引入动态SQL的原因是由于静态SQL不能提供足够的编程灵活性。





## 大表

分区的好处是：

- 可以让单表存储更多的数据
- 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作
- 部分查询能够从查询条件确定只落在少数分区上，速度会很快
- 分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备
- 可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争
- 可以备份和恢复单个分区



作者：黄赟
链接：https://www.zhihu.com/question/30903310/answer/627919520
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



\1. 不要让数据聚集在一台计算机上运行，要均衡分布。比如按照时间分区，按月来分区，那么一个月占一个区，假如查询是查最新的一个月，性能就没什么提高，如果是查询最近6个月，那么一个分一个月是有效分摊服务器资源的。所以看具体应用场景。假如有 10 台 node, 结果查询还是落在了其中一台计算机上，那么这种情况称为 skewed, 即数据倾斜，这台计算机被称为 Hot Spot. 第一大问题就是不要认为分区是提高性能的万能钥匙。分区策略是依据我们查询分析的判断条件，而随时可能变化的。



\2. 分区的路由在哪里计算以及如何计算：Java的 Object.hashCode()， Ruby的 Object#hash 等函数都是可以将key转换成 Hash 的。但是在不同的进程中，这些函数将同一个Key转换出来的 hash 值是可能不一样的。因此不能用来做 分布式存储的 hash 函数。所以应该采用更普适性的[hash函数](https://www.zhihu.com/search?q=hash函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"627919520"})，比如 MD5, FowlerNoll-Vo函数。hash 分区，存储的不是 key 值，而是 给定的hash 值。这倒是很值得思考的。为什么不是key值，而是要计算出来的[hash值](https://www.zhihu.com/search?q=hash值&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"627919520"})。



\3. 分区组合：如果能将 Hash 分区， Range 分区结合起来用，是再好不过了。Cassandra 就是如此的。试想在社交媒体的后台设计中，如果用user id , updated timestamp 结合起来， user id 用来做hasn 分区的标准， updated timestamp 用来做分区标准，那么 一个用户更新的数据，通过先定位partition, 然后再根据 updated timestamp 分区扫描，就比任何一种单纯的分区策略好很多。



\4. 分布式分区的索引可以有分区：

4.1  local index: 可以在数据各分区下面建立索引。索引所包含的数据指针都是指向本分区的

4.2  global index: 可以建立一个完整的索引，包含对每个分区数据的指针，但是按照term分配到不同的分区上。当然global index 的优点很明显，就是可以免去 scatter/gather 的操作，增加了分区命中率，但是也有缺点，多字段的文档，在新建或者修改，删除的时候，需要同时往很多global index 分区中更新索引片段



\5. 分区重分配：Rebalancing Partitions:

5.1. 如果新的节点增加了，原先的平衡被打破，那么怎么建立新的分区平衡

5.2. 如果有新的分区要增加，怎么安排新分区在集群中的分布？

5.3. 如果所有分区的数据量，远远大于[分区节点](https://www.zhihu.com/search?q=分区节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"627919520"})的数量，怎么安排

5.4. 如果有节点退出了，原先的分区平衡被打破，怎么建立新的分区平衡？



\6. 分区的复制：Partition Replication

假如每个分区需要 3 个副本，总共有 4 个分区，那复制集群架构所需要的机器数量是， 4 台。 一台上的分区， 将 其他 3 个分区的 2 个充当其副本。



## 架构

## 1. ORACLE 体系结构

- 数据库：Oracle数据库是数据的物理存储，与其他数据库不一样，这里的数据库只有一个库，可以看作是Oracle就只有一个大数据库

- 实例：一个Oracle实例有一系列的后台进程和内存结构组成。一个数据库可以有n个实例（可以理解为实例是将Oracle数据库加载入内存。一个Oracle可以加载多次，各个实例之间互不干扰，这样相当于安装了许多Oracle）

- 数据文件（dbf）：是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中的。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，除非删除其所属的表空间

- 表空间：（**一个或多个数据文件的逻辑名称**，我们不会直接访问物理名称，比如abc.dbf，而是访问表空间名称，实际上是操作数据文件）一个数据库在逻辑上被划分为一到多个表空间，每个表空间包含在逻辑上相关联的一组结构，每个数据库至少有一个表空间，称为System表空间；表空间下面再划分为段，区，数据库，磁盘块（引入表空间这个逻辑结构，这样就可以将物理结构分布到不同的服务器，降低磁盘压力，同时保证...）

  ![image-20211005193903921](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211005193903921.png)

- 用户是在表空间下建立的。用户登陆后只能看到和操作自己的表, ORACLE 的用户与MYSQL的数据库类似，每建立一个应用需要创建一个用户

  ![image-20211005204205425](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211005204205425.png)
