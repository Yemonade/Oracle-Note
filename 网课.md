# Oracle基础

## 1. ORACLE 体系结构

- 数据库：Oracle数据库是数据的物理存储，与其他数据库不一样，这里的数据库只有一个库，可以看作是Oracle就只有一个大数据库

- 实例：一个Oracle实例有一系列的后台进程和内存结构组成。一个数据库可以有n个实例（可以理解为实例是将Oracle数据库加载入内存。一个Oracle可以加载多次，各个实例之间互不干扰，这样相当于安装了许多Oracle）

- 数据文件（dbf）：是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中的。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，除非删除其所属的表空间

- 表空间：（**一个或多个数据文件的逻辑名称**，我们不会直接访问物理名称，比如abc.dbf，而是访问表空间名称，实际上是操作数据文件）一个数据库在逻辑上被划分为一到多个表空间，每个表空间包含在逻辑上相关联的一组结构，每个数据库至少有一个表空间，称为System表空间；表空间下面再划分为段，区，数据库，磁盘块（引入表空间这个逻辑结构，这样就可以将物理结构分布到不同的服务器，降低磁盘压力，同时保证...）

  ![image-20211005193903921](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211005193903921.png)

- 用户是在表空间下建立的。用户登陆后只能看到和操作自己的表, ORACLE 的用户与MYSQL的数据库类似，每建立一个应用需要创建一个用户

  ![image-20211005204205425](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211005204205425.png)

PS：远程连接oracle

sqlplus system/sys@IP:端口号/全局数据库名（实例名）

eg：sqlplus system/sys@192.168.80.10:1521/orcl

## 2. 一个例子

### 2. 1 创建表空间

事实上就是创建一个数据文件

```sql
create tablespace tname # 创建一个表空间
datafile 'c:\xxx.dbf'   # 存在哪呢
size 100m               # 多大呢
autoextend on           # 满了怎么办
next 10m;                # 自动扩充多少
```

### 2. 2 创建用户

一个用户必须指定在一个表空间上

一个表空间可以有很多用户

```sql
create user lzc           # 账户叫啥名
identified by sys         # 密码
default tablespace tname; # 在哪个表空间创建
```

### 2. 3 用户赋权

然后赋予权限，不然不能登录！

```sql
grant dba to lzc;
```

### 2. 4 表的创建，修改

PS

- ==一定要`commit;`==操作完没有提交或回滚时表处于锁定状态，是个行级锁，操作的行被加锁了
- 系统变量：`sysdate`
- 时间计算
- delete另外一个版本`truncate table xxx` 可以不用提交，因为在本地删除（也就导致不能回滚）；正常的操作语句是创建一个副本；delete语句还会产生碎片

### 2. 5 数据库的导入导出

#### 2. 5. 1 整库的导入导出

在C:/下打开`cmd`

```bash
## 导出，会在当前目录下生成一个叫EXPDAT.DMP的备份文件
exp system/sys full=y
## 同时指定文件名
exp system/sys full=y file=xxx.dmp

## 导入
IMP system/sys full=y
## 指定文件名是同理的
```

#### 2. 5. 2 用户导入导出

在C:/下打开`cmd`

```bash
exp system/sys owner=username file=xxx.dmp
imp system/sys file=xxx.dmp from owner=username
```

#### 2. 5. 3 按表导入导出

```bash
exp username/sys file=xxx.dmp tables=表名1, 表名2

imp username/sys file=xxx.dmp tables=表名1, 表名2
```

## 3. Sql基本操作

## 4. Oracle对象

### 4. 1 视图

视图其实是一个虚拟的表，它的数据其实来自于表。如果更改了视图的数据，表的数据也自然会变化，更改了表的数据，视图也自然会变化。==一个视图所存储的并不是数据，而是一条 SQL语句==
改视图基表数据也会发生变化

1. 简化数据操作：视图可以简化用户处理数据的方式。

2. 着重于特定数据：不必要的数据或敏感数据可以不出现在视图中。 

3. 视图提供了一个简单而有效的安全机制，可以定制不同用户对数据的访问权限。 

4. 提供向后兼容性：视图使用户能够在表的架构更改时为表创建向后兼容接口。

视图一定要有列名，且不能冲突

#### 4. 1. 1 简单视图

如果视图中的语句只是单表查询，并且没有聚合函数，我们就 称之为简单视图

#### 4. 1. 2 带检查约束的视图

添加`with check option` 参数即可

> The `WITH CHECK OPTION` clause can be given for an updatable view to prevent inserts to rows for which the `WHERE` clause in the *`select_statement`* is not true. It also prevents updates to rows for which the `WHERE` clause is true but the update would cause it to be not true (in other words, it prevents visible rows from being updated to nonvisible rows).

#### 4. 1. 3 只读视图

添加`with read only`即可

#### 4. 1. 4 带错误的视图

有的时候，我们创建视图时的表可能并不存在，但是以后可能会存在，我们如果 此时需要创建这样的视图，需要添加 FORCE 选项，SQL语句如下

```sql
create or replace FORCE view view_TEMP as select * from T_TEMP
```

#### 4. 1. 5 复杂视图

所谓复杂视图，就是视图的 SQL语句中，有聚合函数或多表关联查询

**键保留表**：该表的主键列全部显示在视图中,并且它们的值在视图中都是唯一且非空的。也就是说，表的键值在一个连接视图中也是键值，那么就称这个表为键保留表。

复杂视图中若字段来自键保留表，则是可以更新的，反之不能更新



对于聚合函数的查询创建的视图，一定要有列名，尤其对于聚合函数要起别名

**无法修改聚合统计视图**，因为聚合统计视图一定没有键保留表

### 4. 2 物化视图

物化视图与普通的视图相比的区别是物化视图是建立的副本，它类似于一张表，需要占用存储空间。而对一个物化视图查询的执行效率与查询一个表是一样
的

```sql
CREATE METERIALIZED VIEW view_name 
[BUILD IMMEDIATE | BUILD DEFERRED ] REFRESH [FAST|COMPLETE|FORCE] 
[
ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT (next_time) 
]
AS
subquery

BUILD IMMEDIATE 是在创建物化视图的时候就生成数据   默认
BUILD DEFERRED 则在创建时不生成数据，以后根据需要再生成数据。


刷新（REFRESH）：指当基表发生了DML操作后，物化视图何时采用哪种 方式和基表进行同步
--COMPLETE  完全刷新  
--FAST      增量更新
--FORCE     自动选择 默认

--ON COMMIT   在基表做commit提交操作是刷新物化视图
--ON DEMAND   手动刷新  默认
```

#### 4. 2. 1 创建手动刷新的物化视图

```sql
create materialized view xxx 
as
select xxx
```

若执行`insert`操作，再执行`select`操作，会发现新插入的语句并没有出现在物化视图中。我们要通过下面语句手动刷新物化视图

```sql
begin 
DBMS_MVIEW.refresh('xxx','C');
end;

或

EXEC DBMS_MVIEW.refresh('xxx','C'); 
注意：此语句需要在命令窗口中执行。

```

#### 4. 2. 2 创建自动刷新的物化视图

```sql
create materialized view xxx 
refresh on commit
as
select xxx
```

#### 4. 2. 3 创建时不生成数据的物化视图

```sql
create materialized view xxx 
build deferred 
refresh on commit 
as
select
```

我们创建后直接查询会没有结果；需执行以下语句再查询，才会有结果

```sql
begin 
DBMS_MVIEW.refresh('xxx','C');
end;
```

由于我们创建时指定的 on commit ,所以在修改数据后能立刻看到最新数据，无须 再次执行 refresh

#### 4. 2. 4 创建增量刷新的物化视图

前提必须创建物化视图日志：记录基表发生了哪些变化

再用这些记录去更新物化视图

```sql
create materialized view log on tablexxx with rowid； create materialized view log on tablexxx with rowid
```

此外，创建物化视图的语句中，必须有基表的ROWID

```sql
create materialized view xxx 
refresh fast 
as
select t1.rowid t1rowid ,t2.rowid t2rowid, ... from t1, t2
...
## 注意此时还是手动刷新
```

当手动刷新后物化视图会更新，且物化视图日志会清空

当然物化视图一般都要`on commit`，这里是为了演示日志内容所以不这样

### 4. 3 序列

### 4. 4 同义词

### 4. 5 索引

没有索引的话是逐行查询配对的

#### 4. 5. 1 普通索引

```sql
create index 索引名称 on 表名(列名);
```

#### 4. 5. 2 唯一索引

如果我们需要在某个表某个列创建索引，而这列的值是不会重复的。这时我们可 以创建唯一索引。

性能会快一点，还会创建唯一约束，不让插入重复值

```sql
create unique index 索引名称 on 表名(列名);
```

#### 4. 5. 3 复合索引

注意顺序有要求，应该与查询的where语句中的顺序一致

```sql
create index 索引名称 on 表名(列名,列名.....);
```

#### 4. 5. 4 反向索引

应用场景：当某个字段的值为连续增长的值，如果构建标准索引，会形成歪脖子 树。这样会增加查询的层数，性能会下降。建立反向键索引，可以使索引的值变
得不规则，从而使索引树能够均匀分布。

![image-20211006114152999](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211006114152999.png)

```sql
create index 索引名称 on 表名(列名) reverse;
```

#### 4. 5. 5 位图索引

使用场景：位图索引适合创建在低基数列上 位图索引不直接存储 ROWID，而是存储字节位到 ROWID 的映射
优点：减少响应时间，节省空间占用

局限性：只能用=，不能做范围查询；若建立了位图索引又用了范围索引，那么位图索引失效，走普通的查询方式

```sql
create bitmap index 索引名称 on 表名(列名);
```

## 5. 编程

```plsql
[declare]
    -- 声明部分，可选
begin
	-- 执行部分，必须
[exception]
	-- 异常处理部分，可选
end
```

### 5. 1 变量

```plsql
-- 声明：
-- 变量名 类型(长度)

-- 赋值
-- 变量名:=变量值
-- select sth into 变量名
```

### 5. 2 属性类型

%TYPE 

%ROWTYPE

### 5. 3 异常



